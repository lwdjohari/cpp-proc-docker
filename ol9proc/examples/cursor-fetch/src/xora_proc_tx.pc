/* Pro*C transaction helpers implementation 
*  xora_proc_tx.pc 
*/

#define SQLCA_STORAGE_CLASS extern
EXEC SQL INCLUDE sqlca;

// #define STB_DS_IMPLEMENTATION
// #include "stb_ds.h"

#include "xora_proc_contex.h"
#include "xora_proc_helper.h"
#include "xora_proc_tx.h"

#include <stdlib.h>
#include <string.h>

#include "xora_error.h" 
#include "xora_alloc.h"
#include "xora_contex.h"

#include <string.h>
#include <stdio.h>

/*  internals  */

static int __xora_mk_ident_upcase(const char *in, char *out, size_t out_cap)
{
    /* Validate + upcase into out. Returns 0 on ok, -1 on invalid. */
    if (!in || !*in || out_cap < 2)
        return -1;

    size_t n = 0;
    unsigned char c = (unsigned char)in[0];
    if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_'))
        return -1;

    for (size_t i = 0; in[i]; ++i)
    {
        unsigned char ch = (unsigned char)in[i];
        if (!((ch >= 'A' && ch <= 'Z') ||
              (ch >= 'a' && ch <= 'z') ||
              (ch >= '0' && ch <= '9') ||
              ch == '_' || ch == '$' || ch == '#'))
        {
            return -1;
        }
        if (n + 1 >= out_cap)
            return -1; /* overflow */
        out[n++] = (char)((ch >= 'a' && ch <= 'z') ? (ch - 'a' + 'A') : ch);
        if (n > 30)
            return -1; /* Oracle ident max 30 bytes */
    }
    if (n == 0)
        return -1;
    out[n] = '\0';
    return 0;
}

/*  READ WRITE  */

int xora_tx_begin_rw(xora_conn_t *conn)
{
    EXEC SQL CONTEXT USE : conn->ctx;
    EXEC SQL SET TRANSACTION READ WRITE;
    return (sqlca.sqlcode < 0) ? (int)sqlca.sqlcode : 0;
}

int xora_tx_begin_rw_rc(xora_conn_t *conn)
{
    EXEC SQL CONTEXT USE : conn->ctx;
    EXEC SQL SET TRANSACTION READ WRITE ISOLATION LEVEL READ COMMITTED;
    return (sqlca.sqlcode < 0) ? (int)sqlca.sqlcode : 0;
}

int xora_tx_begin_rw_ser(xora_conn_t *conn)
{
    EXEC SQL CONTEXT USE : conn->ctx;
    EXEC SQL SET TRANSACTION READ WRITE ISOLATION LEVEL SERIALIZABLE;
    return (sqlca.sqlcode < 0) ? (int)sqlca.sqlcode : 0;
}

/* READ ONLY  */

int xora_tx_begin_ro(xora_conn_t *conn)
{
    EXEC SQL CONTEXT USE : conn->ctx;
    EXEC SQL SET TRANSACTION READ ONLY;
    return (sqlca.sqlcode < 0) ? (int)sqlca.sqlcode : 0;
}

int xora_tx_begin_ro_rc(xora_conn_t *conn)
{
    EXEC SQL CONTEXT USE : conn->ctx;
    EXEC SQL SET TRANSACTION READ ONLY ISOLATION LEVEL READ COMMITTED;
    return (sqlca.sqlcode < 0) ? (int)sqlca.sqlcode : 0;
}

int xora_tx_begin_ro_ser(xora_conn_t *conn)
{
    EXEC SQL CONTEXT USE : conn->ctx;
    EXEC SQL SET TRANSACTION READ ONLY ISOLATION LEVEL SERIALIZABLE;
    return (sqlca.sqlcode < 0) ? (int)sqlca.sqlcode : 0;
}



xora_err_t xora_tx_commit(xora_conn_t *h)
{
    if (!h)
        return XORA_ERR;

    EXEC SQL BEGIN DECLARE SECTION;
    sql_context lctx;
    EXEC SQL END DECLARE SECTION;

    lctx = h->ctx;
    EXEC SQL CONTEXT USE : lctx;

    EXEC SQL COMMIT WORK;
    if (!XORA_ORA_OK("COMMIT"))
        return XORA_ERR;

    return XORA_OK;
}

xora_err_t xora_tx_rollback(xora_conn_t *h)
{
    if (!h)
        return XORA_ERR;

    EXEC SQL BEGIN DECLARE SECTION;
    sql_context lctx;
    EXEC SQL END DECLARE SECTION;

    lctx = h->ctx;
    EXEC SQL CONTEXT USE : lctx;

    EXEC SQL ROLLBACK WORK;
    if (!XORA_ORA_OK("ROLLBACK"))
        return XORA_ERR;

    return XORA_OK;
}

int xora_tx_savepoint(xora_conn_t *conn, const char *name)
{
    EXEC SQL BEGIN DECLARE SECTION;
    sql_context c;
    char sql[96];
    char ident[64];
    EXEC SQL END DECLARE SECTION;

    if (__xora_mk_ident_upcase(name, ident, sizeof(ident)) != 0)
        return -20001;
    c = conn->ctx;
    EXEC SQL CONTEXT USE : c;

    // (void)snprintf(sql, sizeof(sql), "SAVEPOINT %s", ident);
    EXEC SQL EXECUTE IMMEDIATE : sql;
    return (sqlca.sqlcode < 0) ? (int)sqlca.sqlcode : 0;
}

int xora_tx_rollback_to(xora_conn_t *conn, const char *name)
{
    EXEC SQL BEGIN DECLARE SECTION;
    sql_context c;
    char sql[128];
    char ident[64];
    EXEC SQL END DECLARE SECTION;

    if (__xora_mk_ident_upcase(name, ident, sizeof(ident)) != 0)
        return -20001;
    c = conn->ctx;
    EXEC SQL CONTEXT USE : c;

    //(void)snprintf(sql, sizeof(sql), "ROLLBACK TO SAVEPOINT %s", ident);
    EXEC SQL EXECUTE IMMEDIATE : sql;
    return (sqlca.sqlcode < 0) ? (int)sqlca.sqlcode : 0;
}
